---
title: "tests"
output: html_document
---

Firstly, we load the libraries

```{r setup, include=FALSE}
library(TSP)
library(GA)
library(tidyverse) # Data manipulation
```

## Fitness function

Our fitness function will calculate the negative total distance of the path indicated by the chromosome, because we use GAs to minimize the problem.

```{r cars}
fitness_function <- function(route, dist_matrix) {
  # Add start node to the route (We are not using it)
  route <- c(route, route[1])

  total_distance <- 0
  for (i in 1:(length(route) - 1)) {
    total_distance <- total_distance + dist_matrix[route[i], route[i+1]]
  }
  return(-total_distance)  # Minimize total distance, so return negative
}
```

## Crossover functions

Permutation order crossover

```{r pressure, echo=FALSE}
order_crossover <- function(ga_info, parents) {

  id_parent1 <- parents[1]
  id_parent2 <- parents[2]
  
  parent1 <- ga_info@population[id_parent1, ]
  parent2 <- ga_info@population[id_parent2, ]

  n <- length(parent1)

  # Randomly select two crossover points
  crossover_points <- sort(sample(1:n, 2))
  start <- crossover_points[1]
  end <- crossover_points[2]

  # Create the child with NA values
  child1 <- rep(NA, n)
  child2 <- rep(NA, n)

  # Fill the child with the segment from the first parent
  child1[start:end] <- parent1[start:end]
  child2[1:start] <- parent1[1:start]
  child2[end:n] <- parent1[end:n] 

  # Fill the remaining positions with the genes from the second parent
  
  p2_index_ch1 <- 1
  p2_index_ch2 <- 1
  for (i in 1:n) {
    if (is.na(child1[i])) {
      while (parent2[p2_index_ch1] %in% child1) {
        p2_index_ch1 <- p2_index_ch1 + 1
      }
      child1[i] <- parent2[p2_index_ch1]
    }
    
    if (is.na(child2[i])) {
      while (parent2[p2_index_ch2] %in% child2) {
        p2_index_ch2  <- p2_index_ch2 + 1
      }
      child2[i] <- parent2[p2_index_ch2]
    }
  }

  children <- rbind(child1, child2) 
  fitness <- rep(NA, 2) # They have no fintess value sine they are different from the parents
  
  return(list(children = children, fitness = fitness))
}


```

# Partially Matched Crossover

```{r pressure, echo=FALSE}
partially_matched_crossover <- function(ga_info, parents) {
  id_parent1 <- parents[1]
  id_parent2 <- parents[2]
  
  parent1 <- ga_info@population[id_parent1, ]
  parent2 <- ga_info@population[id_parent2, ]

  n <- length(parent1)

  # Step 1: Select two crossover points
  crossover_points <- sort(sample(1:n, 2))
  start <- crossover_points[1]
  end <- crossover_points[2]

  # Step 2: Initialize children with NA values
  child1 <- rep(NA, n)
  child2 <- rep(NA, n)

  # Step 3: Copy crossover segment from each parent
  child1[start:end] <- parent1[start:end]
  child2[start:end] <- parent2[start:end]

  # Step 4: Fill in genes from parent2 to child1 and parent1 to child2 outside the crossover segment
  for (i in 1:n) {
    # Fill for child1 from parent2
    if (is.na(child1[i])) {
      gene <- parent2[i]
      while (gene %in% child1[start:end]) {
        gene <- parent2[which(parent1 == gene)]
      }
      child1[i] <- gene
    }
    # Fill for child2 from parent1
    if (is.na(child2[i])) {
      gene <- parent1[i]
      while (gene %in% child2[start:end]) {
        gene <- parent1[which(parent2 == gene)]
      }
      child2[i] <- gene
    }
  }

  # Combine children into a matrix and initialize fitness
  children <- rbind(child1, child2) 
  fitness <- rep(NA, 2) # Fitness placeholder
  
  return(list(children = children, fitness = fitness))
}

```

# Cycle Crossover

```{r pressure, echo=FALSE}
cycle_crossover <- function(ga_info, parents) {
  id_parent1 <- parents[1]
  id_parent2 <- parents[2]

  # Retrieve parents from the GA population
  parent1 <- ga_info@population[id_parent1, ]
  parent2 <- ga_info@population[id_parent2, ]

  n <- length(parent1)

  # Initialize children with NA values
  child1 <- rep(NA, n)
  child2 <- rep(NA, n)

  # Track cycles and fill each child based on the cycle
  cycle <- 1
  remaining_positions <- 1:n

  while (length(remaining_positions) > 0) {
    # Start at the first unassigned position
    start <- remaining_positions[1]
    pos <- start
    cycle_positions <- integer(0)

    # Follow the cycle until we return to the start position
    repeat {
      cycle_positions <- c(cycle_positions, pos)
      gene <- parent1[pos]
      pos <- which(parent2 == gene)
      if (pos == start) break
    }

    # Copy genes to children based on the cycle index
    if (cycle %% 2 == 1) {
      # Odd cycles go directly to child1 from parent1, and child2 from parent2
      child1[cycle_positions] <- parent1[cycle_positions]
      child2[cycle_positions] <- parent2[cycle_positions]
    } else {
      # Even cycles go to child1 from parent2, and child2 from parent1
      child1[cycle_positions] <- parent2[cycle_positions]
      child2[cycle_positions] <- parent1[cycle_positions]
    }

    # Update remaining positions and cycle count
    remaining_positions <- setdiff(remaining_positions, cycle_positions)
    cycle <- cycle + 1
  }

  # Combine children into a matrix and initialize fitness
  children <- rbind(child1, child2)
  fitness <- rep(NA, 2) # Placeholder for fitness values
  
  return(list(children = children, fitness = fitness))
}
```

Edge Recombination Crossover (ERX)

```{r}
edge_recombination_crossover <- function(ga_info, parents) {
  id_parent1 <- parents[1]
  id_parent2 <- parents[2]
  
  parent1 <- ga_info@population[id_parent1, ]
  parent2 <- ga_info@population[id_parent2, ]
  
  n <- length(parent1)
  
  # Step 1: Create the edge map
  create_edge_map <- function(p1, p2) {
    edge_map <- vector("list", n)
    
    for (i in 1:n) {
      neighbors <- c()
      # Add neighbors from parent1
      idx <- which(p1 == i)
      neighbors <- c(neighbors, p1[(idx - 1 - 1) %% n + 1], p1[(idx + 1 - 1) %% n + 1])
      
      # Add neighbors from parent2
      idx <- which(p2 == i)
      neighbors <- c(neighbors, p2[(idx - 1 - 1) %% n + 1], p2[(idx + 1 - 1) %% n + 1])
      
      # Remove duplicates
      edge_map[[i]] <- unique(neighbors)
    }
    
    return(edge_map)
  }
  
  edge_map <- create_edge_map(parent1, parent2)
  
  # Step 2: Create child by starting from a random city
  generate_child <- function(edge_map) {
    child <- numeric(n)
    visited <- rep(FALSE, n)
    
    # Start from a random city
    current <- sample(1:n, 1)
    child[1] <- current
    visited[current] <- TRUE
    
    for (i in 2:n) {
      # Remove the current city from its neighbors' lists
      for (j in 1:n) {
        edge_map[[j]] <- setdiff(edge_map[[j]], current)
      }
      
      # Get the neighbors of the current city
      neighbors <- edge_map[[current]]
      
      # Choose the next city
      if (length(neighbors) > 0) {
        # Select the neighbor with the fewest edges in its list
        next_city <- neighbors[which.min(sapply(neighbors, function(x) length(edge_map[[x]])))]
      } else {
        # If no neighbors left, pick an unvisited city at random
        next_city <- sample(which(!visited), 1)
      }
      
      # Add the selected city to the child and mark it as visited
      child[i] <- next_city
      visited[next_city] <- TRUE
      current <- next_city
    }
    
    return(child)
  }
  
  # Generate two children
  child1 <- generate_child(edge_map)
  child2 <- generate_child(edge_map)
  
  # Combine children into a matrix and initialize fitness
  children <- rbind(child1, child2)
  fitness <- rep(NA, 2) # Fitness placeholder
  
  return(list(children = children, fitness = fitness))
}

```

### Greegy crossover

```{r}
adaptive_greedy_subpath_crossover <- function(ga_info, parents, distance_matrix) {
  id_parent1 <- parents[1]
  id_parent2 <- parents[2]
  
  parent1 <- ga_info@population[id_parent1, ]
  parent2 <- ga_info@population[id_parent2, ]
  n <- length(parent1)
  
  # Initialize children with the first city of each parent
  child1 <- rep(0, n)
  child2 <- rep(0, n)
  child1[1] <- parent1[1]
  child2[1] <- parent2[1]
  
  for (i in 1:(n - 1)) {
    for (child_idx in 1:2) {
      child <- if (child_idx == 1) child1 else child2
      parent <- if (child_idx == 1) parent1 else parent2
      
      current_city <- child[i]
      if (is.na(current_city) || current_city == 0) next
      
      # Get positions and next cities with additional checks
      pos_in_parent1 <- match(current_city, parent1)
      pos_in_parent2 <- match(current_city, parent2)
      
      next_in_parent1 <- if (!is.na(pos_in_parent1) && pos_in_parent1 < n) parent1[pos_in_parent1 + 1] else parent1[1]
      next_in_parent2 <- if (!is.na(pos_in_parent2) && pos_in_parent2 < n) parent2[pos_in_parent2 + 1] else parent2[1]
      
      # Safe distance calculations with NA handling
      dist1 <- if (!is.na(next_in_parent1) && next_in_parent1 > 0) distance_matrix[current_city, next_in_parent1] else Inf
      dist2 <- if (!is.na(next_in_parent2) && next_in_parent2 > 0) distance_matrix[current_city, next_in_parent2] else Inf
      
      # Select next city with fallback for unvisited cities
      next_city <- if (!is.infinite(dist1) && !is.infinite(dist2)) {
        if (dist1 < dist2) next_in_parent1 else next_in_parent2
      } else if (!is.infinite(dist1)) {
        next_in_parent1
      } else if (!is.infinite(dist2)) {
        next_in_parent2
      } else {
        # Fallback: select from truly unvisited cities
        unvisited_cities <- setdiff(c(parent1, parent2), child)
        if (length(unvisited_cities) > 0) unvisited_cities[1] else NA
      }
      
      # Assign if not already in child
      if (!is.null(next_city) && !(next_city %in% child)) {
        if (child_idx == 1) child1[i + 1] <- next_city else child2[i + 1] <- next_city
      }
    }
  }
  
  # Ensure unique city visits
  child1 <- enforce_unique_cities(child1, parent1, parent2, distance_matrix)
  child2 <- enforce_unique_cities(child2, parent1, parent2, distance_matrix)
  
  # Final validity check: no zeros, full coverage, and uniqueness
  if (any(child1 == 0) || any(child2 == 0) || length(unique(child1)) < n || length(unique(child2)) < n) {
    stop("Error: Children are incomplete or contain duplicates.")
  }

  return(list(children = rbind(child1, child2), fitness = rep(NA, 2)))
}

# Improved enforce_unique_cities function
enforce_unique_cities <- function(child, parent1, parent2, distance_matrix) {
  unique_cities <- unique(child[child > 0])
  missing_cities <- setdiff(c(parent1, parent2), unique_cities)
  
  # Replace zero entries with missing cities
  zero_indices <- which(child == 0)
  for (i in seq_along(zero_indices)) {
    if (i <= length(missing_cities)) {
      child[zero_indices[i]] <- missing_cities[i]
    }
  }
  
  # Verify uniqueness again
  duplicates <- which(duplicated(child))
  if (length(duplicates) > 0) {
    for (i in duplicates) {
      if (length(missing_cities) > 0) {
        child[i] <- missing_cities[1]
        missing_cities <- missing_cities[-1]
      }
    }
  }
  
  return(child)
}

```

### Random crossover

```{r}
random_crossover_selection <- function(ga_info, parents, distance_matrix) {
  crossover_operators <- list(
    adaptive_greedy_subpath_crossover,
    cycle_crossover,
    order_crossover
  )
  
  # Define the probabilities for each crossover operator
  probabilities <- c(0.33, 0.33, 0.33)
  
  # Select one of the crossover operators based on the probabilities
  random_operator <- sample(1:3, 1, prob = probabilities)
  
  # Call the selected crossover operator and return the result
  if (random_operator == 1) {
    op <- crossover_operators[[random_operator]]
    return(op(ga_info, parents, distance_matrix))
  } else {
    op <- crossover_operators[[random_operator]]
    return(op(ga_info, parents)) 
  }
}
```

## Mutation functions

Swap mutation permutation (**Cal refer, no funciona**)

```{r}
swap_mutation <- function(ga_info, chromosome_id) {

  chromosome <- ga_info@population[chromosome_id, ]
  
  n <- length(chromosome)
  
  # Randomly select two positions to swap
  positions <- sample(1:n, 2)
  
  # Swap the genes at the selected positions
  temp <- chromosome[positions[1]]
  chromosome[positions[1]] <- chromosome[positions[2]]
  chromosome[positions[2]] <- temp
  
  return(chromosome)
}
```

Inverse mutation

```{r}
inverse_mutation <- function(ga_info, chromosome_id) {
  
  # Get the chromosome to mutate
  chromosome <- ga_info@population[chromosome_id, ]
  
  # Get the number of genes in the chromosome
  n <- length(chromosome)
  
  # Randomly select two positions for the inversion
  positions <- sort(sample(1:n, 2))
  
  # Reverse the sequence between the selected positions
  chromosome[positions[1]:positions[2]] <- rev(chromosome[positions[1]:positions[2]])
  
  return(chromosome)
}

```

Insert mutation:

```{r}
insert_mutation <- function(ga_info, chromosome_id) {
  
  # Get the chromosome to mutate
  chromosome <- ga_info@population[chromosome_id, ]
  
  # Get the number of genes in the chromosome
  n <- length(chromosome)
  
  # Randomly select two positions: one to remove from and one to insert into
  positions <- sample(1:n, 2)
  pos_from <- positions[1]
  pos_to <- positions[2]
  
  # Extract the gene at pos_from
  gene <- chromosome[pos_from]
  
  # Remove the gene at pos_from
  chromosome <- chromosome[-pos_from]
  
  # Insert the gene at pos_to
  chromosome <- append(chromosome, gene, after = pos_to - 1)
  
  return(chromosome)
}

```

Scramble mutation

```{r}
scramble_mutation <- function(ga_info, chromosome_id) {
  
  # Get the chromosome to mutate
  chromosome <- ga_info@population[chromosome_id, ]
  
  # Get the number of genes in the chromosome
  n <- length(chromosome)
  
  # Randomly select two positions for the inversion
  positions <- sort(sample(1:n, 2))
  
  # Reverse the sequence between the selected positions
  chromosome[positions[1]:positions[2]] <- sample(chromosome[positions[1]:positions[2]])
  
  return(chromosome)
}
```

## GA algorithm

Run the functions:

```{r}
calculate_distance_matrix <- function(coords) {
  num_cities <- nrow(coords)
  
  # Matrix to store the distances
  dist_matrix <- matrix(0, nrow = num_cities, ncol = num_cities)
  
  # Calculate the distances between every pair of cities
  for (i in 1:num_cities) {
    for (j in 1:num_cities) {
      # Calculate Euclidean distance between city i and city j
      dist_matrix[i, j] <- sqrt((coords[i, 1] - coords[j, 1])^2 + (coords[i, 2] - coords[j, 2])^2)
    }
  }
  
  return(dist_matrix)
}

plot_tsp_route <- function(coords, route) {
  plot(coords, type = "n", main = "Optimized TSP Route", xlab = "X Coordinate", ylab = "Y Coordinate")
  points(coords, pch = 16, col = "blue")  # Plot cities
  text(coords, labels = 1:nrow(coords), pos = 4, cex = 0.8, col = "blue")  # Label cities

# Draw the path
  for (i in 1:(length(route) - 1)) {
    city_from <- route[i]
    city_to <- route[i + 1]
    lines(coords[c(city_from, city_to), ], col = "red", lwd = 2)
  }
}
```

```{r}
ins <- read_TSPLIB("instances/tsp225.tsp")

print(ins)
```

```{r}
dist_matrix <- calculate_distance_matrix(ins)

print(dim(dist_matrix))
```

```{r}
population_size <- 500
max_generations <- 1000
crossover_prob <- 0.8
mutation_prob <- 0.1
elitism <- base::max(1, round(population_size*0.2))

ga_result <- ga(type = "permutation",  # Chromosomes are permutations (tours)
    fitness = function(route) fitness_function(route, dist_matrix),
    lower = 1, upper = nrow(dist_matrix),  # Cities are indexed from 1 to num_cities
    popSize = population_size,  # Population size
    maxiter = max_generations,  # Number of generations
    pmutation = mutation_prob,  # Mutation probability
    pcrossover = crossover_prob,  # Crossover probability
    crossover = cycle_crossover,  # Pass dist_matrix to crossover
    mutation = inverse_mutation, #gaperm_swMutation  # Mutation function swap_mutation inverse_mutation scramble_mutation insert_mutation
    keepBest = TRUE,
    elitism = elitism
  )

summary(ga_result)
```

```{r}
# Plot
best_route <- c(ga_result@solution, ga_result@solution[1])  # Loop back to the start city
plot_tsp_route(ins, best_route)
```

```{r}
library(parallel)
library(doParallel)
```

ISLANDS GENETIC ALGORITHM

```{r}
population_size <- 500
max_generations <- 800
crossover_prob <- 0.8
mutation_prob <- 0.07
elitism <- 100

ga_result <- gaisl(type = "permutation",  # Chromosomes are permutations (tours)
    fitness = function(route) fitness_function(route, dist_matrix),
    lower = 1, upper = nrow(dist_matrix),  # Cities are indexed from 1 to num_cities
    popSize = population_size,  # Population size
    maxiter = max_generations,  # Number of generations
    pmutation = mutation_prob,  # Mutation probability
    pcrossover = crossover_prob,  # Crossover probability
    crossover = order_crossover, #gaperm_oxCrossover,  # Crossover function: cycle_crossover order_crossover partially_matched_crossover edge_recombination_crossover
    mutation = inverse_mutation, #gaperm_swMutation  # Mutation function swap_mutation inverse_mutation scramble_mutation insert_mutation
    elitism = elitism
  )

summary(ga_result)
```
