---
title: "tests"
output: html_document
date: "2024-10-21"
---

Firstly, we load the libraries

```{r setup, include=FALSE}
library(TSP)
library(GA)
library(tidyverse) # Data manipulation
```

## Fitness function

Our fitness function will calculate the negative total distance of the path indicated by the chromosome, because we use GAs to minimize the problem.

```{r cars}
fitness_function <- function(route, dist_matrix) {
  # Add start node to the route (We are not using it)
  route <- c(route, route[1])

  total_distance <- 0
  for (i in 1:(length(route) - 1)) {
    total_distance <- total_distance + dist_matrix[route[i], route[i+1]]
  }
  return(-total_distance)  # Minimize total distance, so return negative
}
```

## Crossover functions

Permutation order crossover

```{r pressure, echo=FALSE}
order_crossover <- function(ga_info, parents) {

  id_parent1 <- parents[1]
  id_parent2 <- parents[2]
  
  parent1 <- ga_info@population[id_parent1, ]
  parent2 <- ga_info@population[id_parent2, ]

  n <- length(parent1)

  # Randomly select two crossover points
  crossover_points <- sort(sample(1:n, 2))
  start <- crossover_points[1]
  end <- crossover_points[2]

  # Create the child with NA values
  child1 <- rep(NA, n)
  child2 <- rep(NA, n)

  # Fill the child with the segment from the first parent
  child1[start:end] <- parent1[start:end]
  child2[1:start] <- parent1[1:start]
  child2[end:n] <- parent1[end:n] 

  # Fill the remaining positions with the genes from the second parent
  
  p2_index_ch1 <- 1
  p2_index_ch2 <- 1
  for (i in 1:n) {
    if (is.na(child1[i])) {
      while (parent2[p2_index_ch1] %in% child1) {
        p2_index_ch1 <- p2_index_ch1 + 1
      }
      child1[i] <- parent2[p2_index_ch1]
    }
    
    if (is.na(child2[i])) {
      while (parent2[p2_index_ch2] %in% child2) {
        p2_index_ch2  <- p2_index_ch2 + 1
      }
      child2[i] <- parent2[p2_index_ch2]
    }
  }

  children <- rbind(child1, child2) 
  fitness <- rep(NA, 2) # They have no fintess value sine they are different from the parents
  
  return(list(children = children, fitness = fitness))
}


```

# Partially Matched Crossover

```{r pressure, echo=FALSE}
partially_matched_crossover <- function(ga_info, parents) {

  print("Performing Partially matched crossover")
  id_parent1 <- parents[1]
  id_parent2 <- parents[2]
  
  parent1 <- ga_info@population[id_parent1, ]
  parent2 <- ga_info@population[id_parent2, ]

  n <- length(parent1)

  # Randomly select two crossover points
  crossover_points <- sort(sample(1:n, 2))
  start <- crossover_points[1]
  end <- crossover_points[2]

  # Create the children with NA values
  child1 <- rep(NA, n)
  child2 <- rep(NA, n)

  # Copy segment from parent 1 to child 1 and parent 2 to child 2
  child1[start:end] <- parent1[start:end]
  child2[start:end] <- parent2[start:end]

  # Fill in remaining positions for child1 using the order in parent2
  for (i in 1:n) {
    if (is.na(child1[i]) && !(parent2[i] %in% child1)) {
      child1[i] <- parent2[i]
    }
  }

  # Fill in remaining positions for child2 using the order in parent1
  for (i in 1:n) {
    if (is.na(child2[i]) && !(parent1[i] %in% child2)) {
      child2[i] <- parent1[i]
    }
  }

  # Combine children into matrix and create fitness placeholder
  children <- rbind(child1, child2) 
  fitness <- rep(NA, 2) # Placeholder for fitness
  
  print("Crossover done")
  return(list(children = children, fitness = fitness))
}





```
## Mutation functions

Swap mutation permutation (**Cal refer, no funciona**)

```{r}
swap_mutation <- function(ga_info, chromosome_id) {

  chromosome <- ga_info@population[chromosome_id, ]
  
  n <- length(chromosome)
  
  # Randomly select two positions to swap
  positions <- sample(1:n, 2)
  
  # Swap the genes at the selected positions
  temp <- chromosome[positions[1]]
  chromosome[positions[1]] <- chromosome[positions[2]]
  chromosome[positions[2]] <- temp
  
  return(chromosome)
}
```

## GA algorithm

Run the functions:

```{r}
calculate_distance_matrix <- function(coords) {
  num_cities <- nrow(coords)
  
  # Matrix to store the distances
  dist_matrix <- matrix(0, nrow = num_cities, ncol = num_cities)
  
  # Calculate the distances between every pair of cities
  for (i in 1:num_cities) {
    for (j in 1:num_cities) {
      # Calculate Euclidean distance between city i and city j
      dist_matrix[i, j] <- sqrt((coords[i, 1] - coords[j, 1])^2 + (coords[i, 2] - coords[j, 2])^2)
    }
  }
  
  return(dist_matrix)
}
```

```{r}
ins <- read_TSPLIB("instances/berlin52.tsp")

print(ins)
```

```{r}
dist_matrix <- calculate_distance_matrix(ins)

print(dim(dist_matrix))
```

```{r}
population_size <- 50
max_generations <- 200
crossover_prob <- 0.8
mutation_prob <- 0.1

ga_result <- ga(type = "permutation",  # Chromosomes are permutations (tours)
    fitness = function(route) fitness_function(route, dist_matrix),
    lower = 1, upper = nrow(dist_matrix),  # Cities are indexed from 1 to num_cities
    popSize = population_size,  # Population size
    maxiter = max_generations,  # Number of generations
    pmutation = mutation_prob,  # Mutation probability
    pcrossover = crossover_prob,  # Crossover probability
    crossover = partially_matched_crossover, #gaperm_oxCrossover,  # Crossover function
    mutation = swap_mutation #gaperm_swMutation  # Mutation function
  ) #OJU: estem fent les funcions de mutation i crossover que implementa la llibreria, no les nostres perquÃ¨ alguna cosa fa que petin :)

res <- ga_result@solution
best_fitness <- -ga_result@fitnessValue  # Convert back from negative distance to positive

summary(ga_result)
plot(ga_result)
```
